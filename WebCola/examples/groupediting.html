<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Grouped Layout</title>
    <style>
        @import url(../style.css);
        body {
            width:1200px;
        }
        .node {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: move;
        }

        .group {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: move;
            opacity: 0.7;
        }

        .link {
            stroke: #7a4e4e;
            stroke-width: 3px;
            stroke-opacity: 1;
        }

        .label {
            fill: white;
            font-family: Verdana;
            font-size: 25px;
            text-anchor: middle;
            cursor: move;
        }
    </style>
</head>
<body>
    <div class="header" style="float:none; text-align:center" width="100%">
        <h1>Layout with hierarchical grouping</h1>
    </div>
    <div class="svgarea" style="float:left">
        <script src="../extern/d3.v3.js"></script>
        <script src="../cola.v3.min.js"></script>
        <script>

            Array.prototype.in_array_position = function (e) {
                for (i = 0; i < this.length; i++) {
                    if (this[i] == e)
                        return i;
                }
                return -1;
            }

            Array.prototype.move = function (old_index, new_index) {
                if (new_index >= this.length) {
                    var k = new_index - this.length;
                    while ((k--) + 1) {
                        this.push(undefined);
                    }
                }
                this.splice(new_index, 0, this.splice(old_index, 1)[0]);
                return this;
            };

            var width = 960,
                height = 1000;

            var color = d3.scale.category20();

            var cola = cola.d3adaptor()
                .linkDistance(100)
                .avoidOverlaps(true)
                .handleDisconnected(false)
                .size([width, height]);

            var svg = d3.select(".svgarea").append("svg")
                .attr("width", width)
                .attr("height", height);

            //draw all the graph
            var drawPicture = function (graph) {
                cola
                    .nodes(graph.nodes)
                    .links(graph.links)
                    .groups(graph.groups)
                    .start();
                var pad = 3;

                var group = svg.selectAll(".group")
                    .data(graph.groups)
                    .enter().append("rect")
                    .attr("rx", 8).attr("ry", 8)
                    .attr("class", "group")
                    .style("fill", function (d, i) { return color(i); });

                var link = svg.selectAll(".link")
                    .data(graph.links)
                    .enter().append("line")
                    .attr("class", "link");


                var node = svg.selectAll(".node")
                    .data(graph.nodes)
                    .enter().append("rect")
                    .attr("class", "node")
                    .attr("width", function (d) { return d.width - 2 * pad; })
                    .attr("height", function (d) { return d.height - 2 * pad; })
                    .attr("rx", 5).attr("ry", 5)
                    .style("fill", function (d) { return color(3); })
                    .call(cola.drag);

                var label = svg.selectAll(".label")
                    .data(graph.nodes)
                    .enter().append("text")
                    .attr("class", "label")
                    .text(function (d) { return d.name; })
                    .call(cola.drag);

                node.append("title")
                    .text(function (d) { return d.name; });

                cola.on("tick", function () {
                    link.attr("x1", function (d) { return d.source.x; })
                        .attr("y1", function (d) { return d.source.y; })
                        .attr("x2", function (d) { return d.target.x; })
                        .attr("y2", function (d) { return d.target.y; });

                    node.attr("x", function (d) { return d.x - d.width / 2 + pad; })
                        .attr("y", function (d) { return d.y - d.height / 2 + pad; });

                    group.attr("x", function (d) { return d.bounds.x; })
                         .attr("y", function (d) { return d.bounds.y; })
                        .attr("width", function (d) { return d.bounds.width(); })
                        .attr("height", function (d) { return d.bounds.height(); });

                    label.attr("x", function (d) { return d.x; })
                         .attr("y", function (d) {
                             var h = this.getBBox().height;
                             return d.y + h / 4;
                         });
                });

                node.on("click", function () {
                    var e = d3.event,
                        isSelected = d3.select(this).classed("selected");
                    if (e.ctrlKey) {
                        d3.select(this).classed("selected", !isSelected);
                        if (!isSelected) {
                            d3.select(this).style("fill", "teal");
                        } else {
                            d3.select(this).style("fill", function (d) { return color(3); });
                        }
                    } else {
                        d3.selectAll(".selected").classed("selected", false);
                        d3.select(this).style("fill", function (d) { return color(3); });
                    }
                });

                label.on("click", function () {
                    var e = d3.event;
                    var currLabelNode = d3.select(this).data();
                    var currLabelRect = d3.select(d3.selectAll(".node")[0][currLabelNode[0].index]);
                    var isSelected = currLabelRect.classed("selected");

                    if (e.ctrlKey) {
                        currLabelRect.classed("selected", !isSelected);
                        if (!isSelected) {
                            currLabelRect.style("fill", "teal");
                        } else {
                            currLabelRect.style("fill", function (d) { return color(3); });
                        }
                    } else {
                        d3.selectAll(".selected").classed("selected", false);
                        currLabelRect.style("fill", function (d) { return color(3); });
                    }

                });

                group.on("click", function (d, i) {
                    var e = d3.event,
                        isSelected = d3.select(this).classed("selectedgroup");

                    if (e.ctrlKey) {
                        d3.select(this).classed("selectedgroup", !isSelected);
                        if (!isSelected) {
                            d3.select(this).style("fill", "teal");
                        } else {
                            d3.select(this).style("fill", function (d) { return color(i); });
                        }

                    } else {

                        d3.selectAll(".selectedgroup").classed("selectedgroup", false);
                        d3.select(this).style("fill", function (d) { return color(i); });

                    }
                });

                //when click on any place of svg clear the class of selected group/node
                svg.on("mousedown", function () {
                    if (!d3.event.ctrlKey) {
                        d3.selectAll(".selected").classed("selected", false).style("fill", function (d) { return color(3); })
                        d3.selectAll(".selectedgroup").classed("selectedgroup", false);
                        group.style("fill", function (d, i) { return color(i); });
                    }
                });

                //grag group
                var inGroupNodes = [];
                var getParent = function (p, currentGroup) {
                    while (typeof p.parent != "undefined") {
                        p = p.parent;
                        if (p == currentGroup) {
                            break;
                        }
                    }
                    return p;
                };
                var dragGroup = d3.behavior.drag()
                    .origin(function (d) { return d; })
                    .on("dragstart.d3adaptor", function (d, i) {

                        inGroupNodes = d3.selectAll(".node").data().filter(function (v) {
                            return getParent(v, d) == d;
                        });

                        for (var index = 0; index < inGroupNodes.length; index++) {
                            inGroupNodes[index].fixed |= 2;
                            inGroupNodes[index].px = inGroupNodes[index].x;
                            inGroupNodes[index].py = inGroupNodes[index].y;
                        }
                    })
                    .on("drag.d3adaptor", function (d, i) {

                        for (var index = 0; index < inGroupNodes.length; index++) {
                            inGroupNodes[index].px += d3.event.dx;
                            inGroupNodes[index].py += d3.event.dy;
                        }
                        cola.resume();
                    })
                    .on("dragend.d3adaptor", function (d, i) {
                        for (var index = 0; index < inGroupNodes.length; index++) {
                            inGroupNodes[index].fixed &= ~6;
                        }
                    });
                group.call(dragGroup);

                document.onkeyup = function (e) {
                    if (!e.shiftKey) {
                        node.call(cola.drag);
                        label.call(cola.drag);
                        group.call(dragGroup);
                    }
                };

                document.onkeydown = function (e) {
                    var ghost = null;
                    var nodex = -1, nodey = -1;
                    var nodeDropgroup = -1;
                    var shiftDragNode = d3.behavior.drag()
                                    .origin(function (d) { return d; })
                                    .on("dragstart.d3adaptor", function (d) {
                                        ghost = svg.selectAll(".ghost")
                                            .data([d])//need to pass a data set not a single object so need []
                                            .enter().append("rect")
                                            .attr("class", "ghost")
                                            .attr("width", function (d) { return d.width - 2 * pad; })
                                            .attr("height", function (d) { return d.height - 2 * pad; })
                                            .attr("rx", 5).attr("ry", 5)
                                            .style("fill", "green")
                                            .style("opacity", 0.3)
                                            .attr("x", function (d) { return d.x - d.width / 2 + pad; })
                                            .attr("y", function (d) { return d.y - d.height / 2 + pad; });
                                    })
                                    .on("drag.d3adaptor", function (d) {

                                        nodex = d3.event.x - d.width / 2 + pad;
                                        nodey = d3.event.y - d.height / 2 + pad;
                                        ghost.attr("x", function (d) { return nodex; })
                                             .attr("y", function (d) { return nodey; });
                                        if (d3.select(this).classed("node") == true) {
                                            d3.select(this).style("fill", "green");
                                        } else if (d3.select(this).classed("label") == true) {
                                            d3.select(d3.selectAll(".node")[0][d.index]).style("fill", "green");
                                        }
                                        var groupStrokeColor = ["red", "green", "teal", "blue", "yellow",
                                                                "purple", "pink", "khaki", "beige", "ponceau",
                                                                "amaranth", "black", "blush", "brown", "cerise",
                                                                "copper", "coral", "cyan", "erin", "gold"];

                                        var inOneGroup = false;
                                        graph.groups.forEach(function (e, i) {
                                            if (d3.event.x > e.bounds.x &&
                                                d3.event.x < (e.bounds.x + e.bounds.width()) &&
                                                d3.event.y > e.bounds.y &&
                                                d3.event.y < (e.bounds.y + e.bounds.height())) {
                                                group.style("stroke", function (d, vi) { if (vi == i) { return groupStrokeColor[i]; } });
                                                nodeDropgroup = i;
                                                inOneGroup = true;
                                            }
                                        });

                                        if (!inOneGroup) {
                                            group.style("stroke", "#fff");
                                            nodeDropgroup = -1;
                                        }

                                    })
                                    .on("dragend.d3adaptor", function (d) {
                                        d.fixed |= 4;
                                        ghost.remove();
                                        d.x = d.px = nodex;
                                        d.y = d.py = nodey;

                                        //if drag label, link the label to the node
                                        if (d3.select(this).classed("node") == true) {
                                            d3.select(this).style("fill", function (d) { return color(3); });
                                        } else if (d3.select(this).classed("label") == true) {
                                            d3.select(d3.selectAll(".node")[0][d.index]).style("fill", function (d) { return color(3); });
                                        }

                                        //delete the same node index in other group
                                        //traverse each group of allGroup
                                        var deleteSameNode = function (allGroup, currNode) {
                                            allGroup.forEach(function (e, i) {
                                                if (typeof e.leaves != "undefined") {
                                                    var inArrayPosition = e.leaves.in_array_position(currNode);
                                                    if (inArrayPosition != -1) {
                                                        e.leaves.splice(inArrayPosition, 1);
                                                    }
                                                }
                                            });
                                        }

                                        var groupChanged = false;
                                        graph.groups.forEach(function (e, i) {
                                            if (nodeDropgroup == i) {
                                                deleteSameNode(graph.groups, d);
                                                if (typeof e.leaves == "undefined") {
                                                    e.leaves = [];//add attribute "leaves"
                                                }
                                                e.leaves.push(d);
                                                groupChanged = true;
                                            } else if (nodeDropgroup == -1) {

                                                //when nodeDropgroup == -1, group may be changed or not be changed
                                                if (typeof d.parent != "undefined" && d.parent == e) {
                                                    e.leaves.splice(e.leaves.in_array_position(d), 1);
                                                    delete d.parent;//clear parent attribute.
                                                    groupChanged = true;
                                                }
                                            }
                                        });

                                        //check and delete empty group
                                        if (groupChanged) {
                                            for (var index = graph.groups.length - 1; index >= 0; index--) {
                                                if ((typeof graph.groups[index].leaves == "undefined" || graph.groups[index].leaves.length == 0) &&
                                                    (typeof graph.groups[index].groups == "undefined" || graph.groups[index].groups.length == 0)) {
                                                    graph.groups.splice(index, 1);
                                                } else {
                                                    if (typeof graph.groups[index].groups != "undefined") {
                                                        var grouplength = graph.groups[index].groups.length;
                                                        for (var i = grouplength - 1; i >= 0; i--) {
                                                            if ((typeof graph.groups[index].groups[i].leaves == "undefined" || graph.groups[index].groups[i].leaves.length == 0) &&
                                                                (typeof graph.groups[index].groups[i].groups == "undefined" || graph.groups[index].groups[i].groups.length == 0)) {
                                                                graph.groups[index].groups.splice(i, 1);
                                                            }
                                                        }
                                                    }
                                                    if ((typeof graph.groups[index].leaves == "undefined" || graph.groups[index].leaves.length == 0) &&
                                                        (typeof graph.groups[index].groups == "undefined" || graph.groups[index].groups.length == 0)) {
                                                        graph.groups.splice(index, 1);
                                                    }
                                                }
                                            }
                                        }

                                        //must wait till the layout is done. If do not want to wait, how?
                                        cola.on("end", function () {
                                            node.each(function (d) {
                                                d.fixed &= ~4;
                                            });
                                            cola.on("end", null);
                                        });

                                        if (groupChanged) {
                                            d3.selectAll("rect").remove();
                                            d3.selectAll("line").remove();
                                            d3.selectAll("text").remove();
                                            drawPicture(graph);
                                        } else {
                                            cola.start();
                                        }

                                    });

                    var groupGhost = null;
                    var groupx = -1, groupy = -1;
                    var groupDropgroup = -1;
                    var shiftDragGroup = d3.behavior.drag()
                                      .on("dragstart.d3adaptor", function (d) {
                                          groupGhost = svg.selectAll(".ghostgroup")
                                            .data([d])
                                            .enter().append("rect")
                                            .attr("class", "ghostgroup")
                                            .attr("width", function (d) { return d.bounds.width(); })
                                            .attr("height", function (d) { return d.bounds.height(); })
                                            .attr("rx", 8).attr("ry", 8)
                                            .style("fill", "green")
                                            .style("opacity", 0.3)
                                            .attr("x", function (d) { return d.bounds.x; })
                                            .attr("y", function (d) { return d.bounds.y; });
                                          groupx = d.bounds.x;
                                          groupy = d.bounds.y
                                      })
                                      .on("drag.d3adaptor", function (d) {
                                          groupx += d3.event.dx;
                                          groupy += d3.event.dy;
                                          groupGhost.attr("x", function (d) { return groupx; })
                                                    .attr("y", function (d) { return groupy; });

                                          d3.select(this).style("fill", "green");
                                          var groupStrokeColor = ["red", "green", "teal", "blue", "yellow", "purple", "pink", "khaki", "beige", "ponceau"];

                                          var inOneGroup = false;
                                          dragGroupSecondCox = groupx + d.bounds.width() / 2;
                                          graph.groups.forEach(function (e, i) {
                                              if (i != d.gid) {
                                                  if (typeof e.parent != "undefined" && e.parent.gid != d.gid) {
                                                      if ((Math.abs((groupx + d.bounds.width() / 2) - (e.bounds.x + e.bounds.width() / 2)) < (d.bounds.width() + e.bounds.width()) / 2) &&
                                                          (Math.abs((groupy + d.bounds.height() / 2) - (e.bounds.y + e.bounds.height() / 2)) < (d.bounds.height() + e.bounds.height()) / 2)) {
                                                          group.style("stroke", function (d, vi) { if (vi == i) { return groupStrokeColor[i]; } });
                                                          groupDropgroup = i;
                                                          inOneGroup = true;
                                                      }
                                                  } else {
                                                      if ((Math.abs((groupx + d.bounds.width() / 2) - (e.bounds.x + e.bounds.width() / 2)) < (d.bounds.width() + e.bounds.width()) / 2) &&
                                                          (Math.abs((groupy + d.bounds.height() / 2) - (e.bounds.y + e.bounds.height() / 2)) < (d.bounds.height() + e.bounds.height()) / 2)) {
                                                          group.style("stroke", function (d, vi) { if (vi == i) { return groupStrokeColor[i]; } });
                                                          groupDropgroup = i;
                                                          inOneGroup = true;
                                                      }
                                                  }
                                              }
                                          });

                                          if (!inOneGroup) {
                                              group.style("stroke", "#fff");
                                              groupDropgroup = -1;
                                          }
                                      })
                                      .on("dragend.d3adaptor", function (d) {

                                          groupGhost.remove();
                                          d3.select(this).style("fill", function (d, i) { return color(d.gid); });

                                          //delete the same group index in other groups
                                          //traverse each group of allGroup
                                          var deleteSameGroup = function (allGroup, currGroup) {
                                              allGroup.forEach(function (e, i) {
                                                  if (typeof e.groups != "undefined") {
                                                      var inArrayPosition = e.groups.in_array_position(currGroup);
                                                      if (inArrayPosition != -1) {
                                                          e.groups.splice(inArrayPosition, 1);
                                                      }
                                                  }
                                              });
                                          }

                                          var groupChanged = false;
                                          graph.groups.forEach(function (e, i) {
                                              if (groupDropgroup == i) {
                                                  deleteSameGroup(graph.groups, d);
                                                  if (typeof e.groups == "undefined") {
                                                      e.groups = [];
                                                  }
                                                  e.groups.push(d);
                                                  if (e.gid > d.gid) {
                                                      if (typeof d.groups != "undefined" && d.groups.length != 0) {
                                                          graph.groups.move(d.gid, e.gid);
                                                          for (var index = d.groups.length - 1; index >= 0; index--) {
                                                              graph.groups.move(d.gid, e.gid);
                                                          }
                                                      } else {
                                                          graph.groups.move(d.gid, e.gid);
                                                      }
                                                  }
                                                  groupChanged = true;
                                              } else if (groupDropgroup == -1) {
                                                  if (typeof d.parent != "undefined" && d.parent == e) {
                                                      e.groups.splice(e.groups.in_array_position(d), 1);
                                                      delete d.parent;
                                                      groupChanged = true;
                                                  }
                                              }
                                          });

                                          if (groupChanged) {
                                              for (var index = graph.groups.length - 1; index >= 0; index--) {
                                                  if ((typeof graph.groups[index].leaves == "undefined" || graph.groups[index].leaves.length == 0) &&
                                                      (typeof graph.groups[index].groups == "undefined" || graph.groups[index].groups.length == 0)) {
                                                      graph.groups.splice(index, 1);
                                                  } else {
                                                      if (typeof graph.groups[index].groups != "undefined") {
                                                          var grouplength = graph.groups[index].groups.length;
                                                          for (var i = grouplength - 1; i >= 0; i--) {
                                                              if ((typeof graph.groups[index].groups[i].leaves == "undefined" || graph.groups[index].groups[i].leaves.length == 0) &&
                                                                  (typeof graph.groups[index].groups[i].groups == "undefined" || graph.groups[index].groups[i].groups.length == 0)) {
                                                                  graph.groups[index].groups.splice(i, 1);
                                                              }
                                                          }
                                                      }
                                                      if ((typeof graph.groups[index].leaves == "undefined" || graph.groups[index].leaves.length == 0) &&
                                                          (typeof graph.groups[index].groups == "undefined" || graph.groups[index].groups.length == 0)) {
                                                          graph.groups.splice(index, 1);
                                                      }
                                                  }
                                              }
                                          }

                                          cola.on("end", function () {
                                              console.log("layout is done!");
                                              node.each(function (d) {
                                                  d.fixed &= ~4;
                                              });
                                              cola.on("end", null);
                                          });

                                          if (groupChanged) {
                                              d3.selectAll("rect").remove();
                                              d3.selectAll("line").remove();
                                              d3.selectAll("text").remove();
                                              drawPicture(graph);
                                          } else {
                                              cola.start();
                                          }

                                      });

                    if (e.shiftKey) {

                        label.call(function () {
                            this.call(shiftDragNode);
                        });

                        node.call(function () {
                            this.call(shiftDragNode);
                        });

                        //drag group
                        group.call(function () {
                            this.call(shiftDragGroup);
                        });
                    }
                };
            };

            d3.json("graphdata/groupeditinged.json", function (error, graph) {
                               
                drawPicture(graph);

                //add a new node
                d3.selectAll(".addnode")
                        .on("click", function () {
                            var newnodename = "NaN";
                            var frominput = document.getElementById("addnodename").value;

                            if (frominput.trim() != "") {
                                newnodename = frominput.trim();
                            }

                            var newnode1 = { "name": newnodename, "width": 60, "height": 40 };
                            graph.nodes.push(newnode1);

                            d3.selectAll("rect").remove();
                            d3.selectAll("line").remove();
                            d3.selectAll("text").remove();

                            drawPicture(graph);
                        });

                //add selected node/group into a new group
                d3.selectAll(".addgroup")
                        .on("click", function () {
                            var selectedGroups = d3.selectAll(".selectedgroup").data();
                            var selectedNodes = d3.selectAll(".selected").data();
                            var newgroup = { "leaves": [], "groups": [] };

                            //delete the same group index in other groups
                            //traverse each group of allGroup
                            var deleteSameGroup = function (allGroup, currGroup) {
                                allGroup.forEach(function (e, i) {
                                    if (typeof e.groups != "undefined") {
                                        var inArrayPosition = e.groups.in_array_position(currGroup);
                                        if (inArrayPosition != -1) {
                                            e.groups.splice(inArrayPosition, 1);
                                        }
                                    }
                                });
                            }

                            //delete the same node index in other group
                            //traverse each group of allGroup
                            var deleteSameNode = function (allGroup, currNode) {
                                allGroup.forEach(function (e, i) {
                                    if (typeof e.leaves != "undefined") {
                                        var inArrayPosition = e.leaves.in_array_position(currNode);
                                        if (inArrayPosition != -1) {
                                            e.leaves.splice(inArrayPosition, 1);
                                        }
                                    }
                                });
                            }

                            //check whether all the selected group have same parent
                            var sameParentForGroup = false;
                            if (selectedGroups.length != 0) {
                                sameParentForGroup = true;
                                selectedGroups.forEach(function (e) {
                                    if (typeof selectedGroups[0].parent == "undefined" ||
                                        selectedGroups[0].parent != e.parent) {
                                        sameParentForGroup = false;
                                    }
                                });
                            }
                            //check whether all the selected node have same parent
                            var sameParentForNode = false;
                            if (selectedNodes.length != 0) {
                                sameParentForNode = true;
                                selectedNodes.forEach(function (e) {
                                    if (typeof selectedNodes[0].parent == "undefined" ||
                                        selectedNodes[0].parent != e.parent) {
                                        sameParentForNode = false;
                                    }
                                });
                            }


                            if (sameParentForGroup && sameParentForNode &&
                                selectedNodes[0].parent == selectedGroups[0].parent) {

                                selectedGroups.forEach(function (e) {
                                    newgroup.groups.push(e);
                                    deleteSameGroup(graph.groups, e);
                                });
                                selectedNodes.forEach(function (e) {
                                    newgroup.leaves.push(e);
                                    deleteSameNode(graph.groups, e);
                                });
                                if (typeof selectedGroups[0].parent.groups == "undefined") {
                                    selectedGroups[0].parent.groups = [];
                                }
                                selectedGroups[0].parent.groups.push(newgroup);
                                graph.groups.splice(selectedGroups[0].parent.gid + 1, 0, newgroup);
                            } else if (sameParentForGroup && !sameParentForNode &&
                                selectedNodes.length == 0) {

                                selectedGroups.forEach(function (e) {
                                    newgroup.groups.push(e);
                                    deleteSameGroup(graph.groups, e);
                                });
                                if (typeof selectedGroups[0].parent.groups == "undefined") {
                                    selectedGroups[0].parent.groups = [];
                                }
                                //update reference of parent group
                                selectedGroups[0].parent.groups.push(newgroup);
                                //insert newgroup after parent group
                                graph.groups.splice(selectedGroups[0].parent.gid + 1, 0, newgroup);

                            } else if (!sameParentForGroup && sameParentForNode &&
                                selectedGroups.length == 0) {

                                selectedNodes.forEach(function (e) {
                                    newgroup.leaves.push(e);
                                    deleteSameNode(graph.groups, e);
                                });
                                if (typeof selectedNodes[0].parent.groups == "undefined") {
                                    selectedNodes[0].parent.groups = [];
                                }
                                //update reference of parent group
                                selectedNodes[0].parent.groups.push(newgroup);
                                //insert newgroup after parent group
                                graph.groups.splice(selectedNodes[0].parent.gid + 1, 0, newgroup);
                            } else {

                                //add selected groups into newgroup.groups and delete same group index in other groups
                                selectedGroups.forEach(function (e) {
                                    newgroup.groups.push(e);
                                    deleteSameGroup(graph.groups, e);
                                });

                                //add selected nodes into newgroup.leaves and delete same node index in other groups
                                selectedNodes.forEach(function (e) {
                                    newgroup.leaves.push(e);
                                    deleteSameNode(graph.groups, e);
                                });
                                var newgroupGids = [];//decide insert location
                                newgroup.groups.forEach(function (e) {
                                    newgroupGids.push(e.gid);
                                });
                                //if newgroupGids is empty insertLocation is infinity.
                                var insertLocation = Math.min.apply(Math, newgroupGids);
                                graph.groups.splice(insertLocation, 0, newgroup);
                            }

                            for (var index = graph.groups.length - 1; index >= 0; index--) {
                                if ((typeof graph.groups[index].leaves == "undefined" || graph.groups[index].leaves.length == 0) &&
                                    (typeof graph.groups[index].groups == "undefined" || graph.groups[index].groups.length == 0)) {
                                    graph.groups.splice(index, 1);
                                } else {
                                    if (typeof graph.groups[index].groups != "undefined") {
                                        var grouplength = graph.groups[index].groups.length;
                                        for (var i = grouplength - 1; i >= 0; i--) {
                                            if ((typeof graph.groups[index].groups[i].leaves == "undefined" || graph.groups[index].groups[i].leaves.length == 0) &&
                                                (typeof graph.groups[index].groups[i].groups == "undefined" || graph.groups[index].groups[i].groups.length == 0)) {
                                                graph.groups[index].groups.splice(i, 1);
                                            }
                                        }
                                    }
                                    if ((typeof graph.groups[index].leaves == "undefined" || graph.groups[index].leaves.length == 0) &&
                                        (typeof graph.groups[index].groups == "undefined" || graph.groups[index].groups.length == 0)) {
                                        graph.groups.splice(index, 1);
                                    }
                                }
                            }
                            d3.selectAll("rect").remove();
                            d3.selectAll("line").remove();
                            d3.selectAll("text").remove();
                            drawPicture(graph);
                        });


            });

        </script>
    </div>
    <div class="grapharea" style="float:right">
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        input node name: <br /><input type="text" style="width:150px" id="addnodename" /><br />
        <input type="button" value="add node" style="width:157px" class="addnode" onclick="javascript:void(0)" />
        <br />
        <input type="button" value="add group" style="width:157px" class="addgroup" onclick="javascript:void(0)" />
    </div>
    <div class="description" style="float:left">
        <p>
            This graph can be edited.<br/>
            1. Input a name, then click addnode button to click a new node. If nothing input, a new node is named NaN.<br />
            2. Press Shift key and click on a node or group. Then this node/group can be dragged into/out a group.<br />
            3. Press Ctrl key and select nodes/groups. Then click addgroup button. A new group will be created which contains the nodes/groups selected before.<br />
        </p>
    </div>
</body>
</html>

